# Make the output raster template
output <- rast(ext(input), crs = crs(input), resolution = cellsize)
output
# Remove levels if any
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
count
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
num_vals_output
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
count
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
n_left
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
ncell(output) - num_vals_output - sum(count$output_count)
count
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
count
data.frame(freq(input)[, c('value', 'count')])
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
count
n_left
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
n_left
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
count
table(c(NA, NA, NA, NA, NA, NA))
seq(NA, 8)
rep(NA, 8)
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 1000))
}
}
# Overlay the base and target map
zones <- output; values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, input, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
input
cn <- zonal(input, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname)
gc()
fname
Sys.info()[['sysname']]
# Group by Output object and cell value, count, and determine percentage
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
librayr(parallel)
library(parallel)
# Group by Output object and cell value, count, and determine percentage
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
n <- 1
cn[[n, 'input']]
x <- cn[[n, 'input']]
classes <- count$value
is.na(x)
all(is.na(x))
rep(NA, length(classes))
areal_per <- do.call(rbind, mclapply(1:nrow(cn), function(n) {
props <- get_proportion(cn[[n, 'input']], count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- cn[[n, 'id']]
dt[, c('id', count$value)]
}, mc.cores = detectCores()))
areal_per
View(areal_per)
rm(cn)
inds <- apply(areal_per[, -1] == 1000, 1, match, x = TRUE)
areal_per$cat <- count$value[inds]; rm(inds)
count$value
# Pick pixels in target map for classes
for (class_id in count$value) {
# Calculate the number of remaining pixels to assign
num_to_fill <- count[count$value == class_id, 'output_count'] -
sum(na.omit(areal_per$cat) == class_id)
# In case more than output_count pixels have been assigned
if (num_to_fill < 0) num_to_fill <- 0
# Get the column of this class
per_this_class <- areal_per[[as.character(class_id)]]
# Remove pixels that have assigned class already
per_this_class[which(!is.na(areal_per$cat))] <- NA
# Remove pixels with less than 10% to be this class
# to reduce calculation
per_this_class[per_this_class <= 100] <- NA
# Pick up num_to_fill of pixels with the most coverage to assign class
num_to_fill <- min(num_to_fill, sum(!is.na(per_this_class)))
inds_to_fill <- order(per_this_class, decreasing = T)[1:num_to_fill]
areal_per$cat[inds_to_fill]= as.integer(class_id)
}
# Clean up
rm(num_to_fill, per_this_class, inds_to_fill)
View(areal_per)
# Clean up and return
values(output) <- areal_per$cat
plot(output)
plot(input)
coltab(output) <- coltab(input)
plot(output)
plot(input)
output
devtools::document()
devtools::install()
library(terra)
library(dplyr)
library(sf)
fname <- '/Users/leisong/Dropbox/research/hrlcm/results/tanzania/prediction/landcover.tif'
input <- rast(fname)
cellsize <- 1000
no_data = NA
# Make the output raster template
output <- rast(ext(input), crs = crs(input), resolution = cellsize)
# Remove levels if any
levels(input) <- NULL
load("~/Dropbox/research/APUpscale/count.rda")
load("~/Dropbox/research/APUpscale/num_vals_output.rda")
test <- do.call(rbind, mclapply(1:ncell(output), function(n) {
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
piece <- crop(base_map,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
}, mc.cores = detectCores()))
library(parallel)
test <- do.call(rbind, mclapply(1:ncell(output), function(n) {
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
piece <- crop(base_map,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
}, mc.cores = detectCores()))
output
fname_target <- '/Users/leisong/downloads/target.tif'
?writeRaster
writeRaster(output, fname_target,
datatype = 'INT1U',
gdal = c("COMPRESS=LZW"))
?rast
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize, vals = NA)
output
writeRaster(output, fname_target,
datatype = 'INT1U',
gdal = c("COMPRESS=LZW"))
test <- do.call(rbind, mclapply(1:ncell(output), function(n) {
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
target_map <- rast(fname_target)
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
}, mc.cores = detectCores()))
n
n <- 1
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
target_map <- rast(fname_target)
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 1000))
}
}
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
target_map <- rast(fname_target)
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
rm(dt, test, vals, piece)
rm(target_map)
rm(n, n_col, n_row)
rm(n_cols)
rm(no_data)
rm(props)
test <- do.call(rbind, mclapply(1:ncell(output), function(n) {
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
target_map <- rast(fname_target)
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
}, mc.cores = detectCores()))
gc()
nrow(output)
do.call(rbind, lapply(1:ncol(output), function(n_col) {
piece <- crop(input,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_row + (n_col - 1) * nrow(output)
dt[, c('id', count$value)]
}))
n_row <- 1
do.call(rbind, lapply(1:ncol(output), function(n_col) {
piece <- crop(input,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_row + (n_col - 1) * nrow(output)
dt[, c('id', count$value)]
}))
nrow(output
)
1233 * 1.4 / 60
detectCores(logical = F)
n <- 1
Sys.time()
tm <- Sys.time()
n_cols <- ncol(output)
n_col <- n %% n_cols
n_row <- n %/% n_cols + 1
base_map <- rast(fname)
target_map <- rast(fname_target)
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
Sys.time() - tm
0.15 * ncell(output) / 8 / 60
tm <- Sys.time()
test <- mclapply(1:nrow(output), function(n_row) {
base_map <- rast(fname)
target_map <- rast(fname_target)
do.call(rbind, lapply(1:ncol(output), function(n_col) {
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_row + (n_col - 1) * nrow(output)
dt[, c('id', count$value)]
}))
}, mc.core = detectCores())
Sys.time() - tm
n_row
base_map <- rast(fname)
target_map <- rast(fname_target)
ncol(output)
do.call(rbind, lapply(1:ncol(output), function(n_col) {
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_row + (n_col - 1) * nrow(output)
dt[, c('id', count$value)]
}))
n_rows <- nrow(output)
n_cols <- ncol(output)
n_cells <- ncell(output)
tm <- Sys.time()
n_rows <- nrow(output)
n_cols <- ncol(output)
n_cells <- ncell(output)
test <- mclapply(1:n_cols, function(n_col) {
base_map <- rast(fname)
target_map <- rast(fname_target)
do.call(rbind, lapply(1:n_rows, function(n_row) {
piece <- crop(base_map,
target_map[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_col + (n_row - 1) * n_cols
dt[, c('id', count$value)]
}))
}, mc.core = detectCores())
Sys.time() - tm
tm <- Sys.time()
n_rows <- nrow(output)
n_cols <- ncol(output)
n_cells <- ncell(output)
test <- lapply(1:n_cols, function(n_col) {
do.call(rbind, lapply(1:n_rows, function(n_row) {
piece <- crop(input,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_col + (n_row - 1) * n_cols
dt[, c('id', count$value)]
}))
})
Sys.time() - tm
gc()
nlcd_conus_path <- '/Users/leisong/Downloads/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
# Define an Area of Interest and transform to NLCD CRS
AOI <- USAboundaries::us_states(resolution = "low", states = 'Utah') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
input
cellsize = 1000
nthread = detectCores()
# Make the output raster template
output <- rast(ext(input), crs = crs(input), resolution = cellsize)
# Remove levels if any
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
count
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 1000))
}
}
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
# Convert to use raster and do paralleling calculation
## Workable for super large map
input <- raster(input)
library(raster)
input <- raster(input)
output <- raster(output)
n_rows <- nrow(output)
n_cols <- ncol(output)
n_cells <- ncell(output)
# Group by Output object and cell value, count, and determine percentage
areal_per <- do.call(
rbind, lapply(1:n_rows, function(n_row) {
do.call(rbind, mclapply(1:n_cols, function(n_col) {
piece <- crop(input,
output[n_row, n_col, drop = FALSE],
snap = 'out', mask = TRUE)
vals <- values(piece)
props <- get_proportion(vals, count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n_col + (n_row - 1) * n_cols
dt[, c('id', count$value)]
}, mc.cores = nthread))
})); rm(n_rows, n_cols, n_cells)
gc()
