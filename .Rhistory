# Get the column of this class
per_this_class <- areal_per[[as.character(class_id)]]
# Remove pixels that have assigned class already
per_this_class[which(!is.na(areal_per$cat))] <- NA
# Remove pixels with less than 10% to be this class
# to reduce calculation
per_this_class[per_this_class <= 1000] <- NA
# Pick up num_to_fill of pixels with the most coverage to assign class
num_to_fill <- min(num_to_fill, sum(!is.na(per_this_class)))
if (num_to_fill > 0) {
inds_to_fill <- order(per_this_class, decreasing = T)[1:num_to_fill]
areal_per$cat[inds_to_fill]= as.integer(class_id)}
}
# If a cell is unassigned, implement a majority rule
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))])),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)]),
as.numeric(areal_per$cat))
# Clean up
rm(num_to_fill, per_this_class, inds_to_fill)
free_RAM(); gc()
# Message
if (verbose) message(sprintf("Reassign values - %s.", Sys.time()))
# Reshape the result to tiles
target_cats <- mclapply(seq_along(ids_in_group), function(n) {
inds <- ids_in_group[[n]]
n_row <- n_row_cols[[n]][1]
n_col <- n_row_cols[[n]][2]
matrix(areal_per$cat[inds], nrow = n_row, ncol = n_col, byrow = TRUE)
}, mc.cores = min(length(ids_in_group), nthread))
rm(areal_per, ids_in_group, n_row_cols)
unlink(temp_dir, recursive = TRUE)
# Message
if (verbose) message(sprintf('Reshape the matrix - %s.', Sys.time()))
# Mosaic the matrices
ids_to_rbind <- 1:length(target_cats) %% dims_out[2]
do.call(cbind, mclapply(unique(ids_to_rbind), function(n) {
do.call(rbind, target_cats[which(ids_to_rbind == n)])
}, mc.cores = min(length(unique(ids_to_rbind)), nthread)))
}
# Summarize the output cells
target_vals <- reclass(input,
output = output,
nthread = nthread,
verbose = verbose)
gc()
devtools::document()
gc()
free_RAM()
gc()
devtools::document()
devtools::install()
devtools::install()
library(APUpscale)
library(terra)
nlcd <- rast(system.file('extdata/nlcd_dukes.tif', package = "APUpscale"))
lc_coarse <- upscale(nlcd, cellsize = 1000, nthread = 2, verbose = TRUE)
coltab(lc_coarse) <- coltab(nlcd)
plot(lc_coarse)
mem_info(nlcd)
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
nlcd@ptr$mem_needs(opt)
nlcd@ptr$mem_needs(opt)[1] / (1024^3 / 8)
input <- nlcd
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- input@ptr$mem_needs(opt)[1] / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
mem_need
mem_avail
mem_need / mem_avail
ceiling(mem_need / mem_avail)
num_tiles
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / mem_avail)
mem_need / mem_avail
cellsize <- 1000
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
zones <- output; values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, input, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(input, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname)
cn
n <- 1
cn[n, 'input']
cn[[n, 'input']]
props <- get_proportion(cn[[n, 'input']], count$value)
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 10000))
}
}
props <- get_proportion(cn[[n, 'input']], count$value)
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname, overwrite = TRUE,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
props <- get_proportion(cn[[n, 'input']], count$value)
props
dt <- data.frame(t(props))
names(dt) <- count$value
cn$id
dt$id <- n
dt[, c('id', count$value)]
# Group by Output object and cell value, count, and determine percentage
areal_per <- do.call(
rbind, lapply(1:nrow(cn), function(n) {
props <- get_proportion(cn[[n, 'input']], count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
})); rm(cn)
areal_per
# Re-class the target pixels
## Fill all cells with 100% of one class with that class
inds <- apply(areal_per[, -1] == 10000, 1, match, x = TRUE)
areal_per$cat <- count$value[inds]; rm(inds)
areal_per
# Pick pixels in target map for classes
for (class_id in count$value) {
# Calculate the number of remaining pixels to assign
num_to_fill <- count[count$value == class_id, 'output_count'] -
sum(na.omit(areal_per$cat) == class_id)
# In case more than output_count pixels have been assigned
if (num_to_fill < 0) num_to_fill <- 0
# Get the column of this class
per_this_class <- areal_per[[as.character(class_id)]]
# Remove pixels that have assigned class already
per_this_class[which(!is.na(areal_per$cat))] <- NA
# Remove pixels with less than 10% to be this class
# to reduce calculation
per_this_class[per_this_class <= 1000] <- NA
# Pick up num_to_fill of pixels with the most coverage to assign class
num_to_fill <- min(num_to_fill, sum(!is.na(per_this_class)))
if (num_to_fill > 0) {
inds_to_fill <- order(per_this_class, decreasing = T)[1:num_to_fill]
areal_per$cat[inds_to_fill]= as.integer(class_id)}
}
# If a cell is unassigned, implement a majority rule
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))])),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)]),
as.numeric(areal_per$cat))
# Clean up
rm(num_to_fill, per_this_class, inds_to_fill)
View(areal_per)
count$value
View(areal_per)
devtools::document()
devtools::install()
library(APUpscale)
library(terra)
nlcd <- rast(system.file('extdata/nlcd_dukes.tif', package = "APUpscale"))
lc_coarse <- upscale(nlcd, cellsize = 1000, nthread = 2, verbose = TRUE)
library(APUpscale)
library(terra)
nlcd <- rast(system.file('extdata/nlcd_dukes.tif', package = "APUpscale"))
lc_coarse <- upscale(nlcd, cellsize = 1000, nthread = 2, verbose = TRUE)
coltab(lc_coarse) <- coltab(nlcd)
plot(lc_coarse)
plot(nlcd)
writeRaster(lc_coarse, '/Users/pinot/download/upscale.tif')
writeRaster(lc_coarse, '/Users/pinot/downloads/upscale.tif')
writeRaster(nlcd, '/Users/pinot/downloads/orig.tif')
input <- nlcd
no_data = NA
cellsize <- 1000
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
library(parallel)
nthread <- detectCores()
# Remove levels if any
levels(input) <- NULL
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname, overwrite = TRUE,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
# Message
if (verbose) message(sprintf('Summarize cells - %s.', Sys.time()))
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 10000))
}
}
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
verbose <- FALSE
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- input@ptr$mem_needs(opt)[1] / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- mem_need / mem_avail
num_tiles
zones <- output; values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, input, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(input, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname)
# Group by Output object and cell value, count, and determine percentage
areal_per <- do.call(
rbind, lapply(1:nrow(cn), function(n) {
props <- get_proportion(cn[[n, 'input']], count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
})); rm(cn)
# Re-class the target pixels
## Fill all cells with 100% of one class with that class
inds <- apply(areal_per[, -1] == 10000, 1, match, x = TRUE)
areal_per$cat <- count$value[inds]; rm(inds)
# Pick pixels in target map for classes
for (class_id in count$value) {
# Calculate the number of remaining pixels to assign
num_to_fill <- count[count$value == class_id, 'output_count'] -
sum(na.omit(areal_per$cat) == class_id)
# In case more than output_count pixels have been assigned
if (num_to_fill < 0) num_to_fill <- 0
# Get the column of this class
per_this_class <- areal_per[[as.character(class_id)]]
# Remove pixels that have assigned class already
per_this_class[which(!is.na(areal_per$cat))] <- NA
# Remove pixels with less than 10% to be this class
# to reduce calculation
per_this_class[per_this_class <= 1000] <- NA
# Pick up num_to_fill of pixels with the most coverage to assign class
num_to_fill <- min(num_to_fill, sum(!is.na(per_this_class)))
if (num_to_fill > 0) {
inds_to_fill <- order(per_this_class, decreasing = T)[1:num_to_fill]
areal_per$cat[inds_to_fill]= as.integer(class_id)}
}
View(areal_per)
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)])
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)
# If a cell is unassigned, implement a majority rule
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))])),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)]),
as.numeric(areal_per$cat))
values(output) <- areal_per$cat
plot(output)
coltab(output) <- coltab(nlcd)
plot(output)
zones <- output; values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, input, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(input, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname)
# Group by Output object and cell value, count, and determine percentage
areal_per <- do.call(
rbind, lapply(1:nrow(cn), function(n) {
props <- get_proportion(cn[[n, 'input']], count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- n
dt[, c('id', count$value)]
})); rm(cn)
# Re-class the target pixels
## Fill all cells with 100% of one class with that class
inds <- apply(areal_per[, -1] == 10000, 1, match, x = TRUE)
areal_per$cat <- count$value[inds]; rm(inds)
count
# Pick pixels in target map for classes
for (class_id in count$value) {
# Calculate the number of remaining pixels to assign
num_to_fill <- count[count$value == class_id, 'output_count'] -
sum(na.omit(areal_per$cat) == class_id)
# In case more than output_count pixels have been assigned
if (num_to_fill < 0) num_to_fill <- 0
# Get the column of this class
per_this_class <- areal_per[[as.character(class_id)]]
# Remove pixels that have assigned class already
per_this_class[which(!is.na(areal_per$cat))] <- NA
# Remove pixels with less than 10% to be this class
# to reduce calculation
per_this_class[per_this_class <= 1000] <- NA
# Pick up num_to_fill of pixels with the most coverage to assign class
num_to_fill <- min(num_to_fill, sum(!is.na(per_this_class)))
if (num_to_fill > 0) {
inds_to_fill <- order(per_this_class, decreasing = T)[1:num_to_fill]
areal_per$cat[inds_to_fill]= as.integer(class_id)}
}
View(areal_per)
ids <- is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))]))
ids
test <- areal_per[ids, ]
is.na(rowSums(areal_per[, -c(1, ncol(areal_per))])
)
ids <- is.na(areal_per$cat)
test <- areal_per[ids, ]
View(test)
ncol(areal_per)
View(areal_per)
sum(is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))])))
rowSums(areal_per[, -c(1, ncol(areal_per))])
ids1 <- is.na(areal_per$cat)
ids2 <- !is.na(rowSums(areal_per[, -c(1, ncol(areal_per))]))
ids
ids1 & ids2
View(areal_per)
ids1 <- 1:nrow(areal_per)[ids1]
ids1 <- is.na(areal_per$cat)
ids1 <- (1:nrow(areal_per))[ids1]
ids1
ids2 <- (1:nrow(areal_per))[ids2]
intersect(ids1. ids2)
intersect(ids1, ids2)
View(areal_per)
View(test)
is.na(areal_per$cat) &
!is.na(rowSums(areal_per[, -c(1, ncol(areal_per))], na.rm = T))
rowSums(areal_per[, -c(1, ncol(areal_per))], na.rm = T)
rowSums(test)
rowSums(test, na.rm = T)
colSums(is.na(areal_per[, -c(1, ncol(areal_per))])) == nrow(areal_per[, -c(1, ncol(areal_per))])
rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) == ncol(areal_per[, -c(1, ncol(areal_per))])
is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) ==
ncol(areal_per[, -c(1, ncol(areal_per))])
sum(is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) ==
ncol(areal_per[, -c(1, ncol(areal_per))]))
# If a cell is unassigned, implement a majority rule
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) ==
ncol(areal_per[, -c(1, ncol(areal_per))]),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)]),
as.numeric(areal_per$cat))
# If a cell is unassigned, implement a majority rule
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) == ncol(areal_per[, -c(1, ncol(areal_per))]),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)]),
as.numeric(areal_per$cat))
pmax(areal_per[, -c(1, ncol(areal_per))])
apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)
# If a cell is unassigned, implement a majority rule
ids <- is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) ==
ncol(areal_per[, -c(1, ncol(areal_per))])
ids
unlist(sapply(apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)], function(x) x[1]))
unlist(sapply(apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max), function(x) x[1]))
x <- 1
x <- apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max)
x[[1]]
x[[10]]
x[[11]]
x[[120]]
x[[121]]
x[[122]]
x[[123]]
x[[124]]
x
x[[984]]
unlist(apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max))
unlist(sapply(apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max), function(x) unname(x[1])))
areal_per$cat <- ifelse(
is.na(areal_per$cat) &
!rowSums(is.na(areal_per[, -c(1, ncol(areal_per))])) ==
ncol(areal_per[, -c(1, ncol(areal_per))]),
as.numeric(colnames(areal_per[, -c(1, ncol(areal_per))])[
unlist(sapply(apply(areal_per[, -c(1, ncol(areal_per))], 1, which.max),
function(x) unname(x[1])))]),
as.numeric(areal_per$cat))
View(areal_per)
values(output) <- areal_per$cat
coltab(output) <- coltab(nlcd)
plot(output)
devtools::document()
devtools::install()
library(APUpscale)
library(terra)
nlcd <- rast(system.file('extdata/nlcd_dukes.tif', package = "APUpscale"))
lc_coarse <- upscale(nlcd, cellsize = 1000, nthread = 2, verbose = TRUE)
coltab(lc_coarse) <- coltab(nlcd)
plot(lc_coarse)
writeRaster(lc_coarse, '/Users/pinot/downloads/coarse.tif')
library(terra)
library(dplyr)
library(sf)
nlcd_conus_path <- '/Users/pinot/Dropbox/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
nlcd_conus_path <- '/Users/pinot/downloads/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
# Define an Area of Interest and transform to NLCD CRS
AOI <- USAboundaries::us_states(resolution = "low", states = 'Utah') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
lc_coarse <- upscale(input, cellsize = 1000, verbose = TRUE)
coltab(lc_coarse) <- coltab(input)
writeRaster(input, '/Users/pinot/downloads/orig_utah.tif')
writeRaster(lc_coarse, '/Users/pinot/downloads/coarse_utah.tif')
AOI <- USAboundaries::us_counties(resolution = "low", states = 'MA') %>%
dplyr::select(-state_name) %>%
dplyr::filter(namelsad == 'Worcester County') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
lc_coarse <- upscale(input, cellsize = 1000, verbose = TRUE)
coltab(lc_coarse) <- coltab(input)
writeRaster(input, '/Users/pinot/downloads/orig_wor.tif')
writeRaster(lc_coarse, '/Users/pinot/downloads/coarse_wor.tif')
lc_coarse <- upscale(input, cellsize = 100, verbose = TRUE)
coltab(lc_coarse) <- coltab(input)
writeRaster(lc_coarse, '/Users/pinot/downloads/coarse_wor_100.tif')
devtools::document()
devtools::check()
devtools::check()
devtools::install()
