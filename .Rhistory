rm(input, output, template); free_RAM(); gc()
input <- nlcd
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
# Remove levels if any
levels(input) <- NULL
temp_dir <- file.path(tempdir(), 'tiles')
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
dims_out <- c(nrow(template), ncol(template))
output_tiles <- makeTiles(
output, template,
filename = file.path(temp_dir, 'output_.tif'))
input_tiles <- makeTiles(
input, template,
filename = file.path(temp_dir, 'input_.tif'))
rm(num_tiles, num_factor, mem_need, mem_avail)
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- (input@ptr$mem_needs(opt)[1] +
output@ptr$mem_needs(opt)[1]) / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / floor(mem_avail / nthread))
num_tiles <- ifelse(num_tiles %/% 2 == 0, num_tiles, num_tiles + 1)
num_factor <- ceiling(sqrt(ncell(output) / num_tiles))
# Split raster to tiles
temp_dir <- file.path(tempdir(), 'tiles')
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
dims_out <- c(nrow(template), ncol(template))
output_tiles <- makeTiles(
output, template,
filename = file.path(temp_dir, 'output_.tif'))
input_tiles <- makeTiles(
input, template,
filename = file.path(temp_dir, 'input_.tif'))
rm(num_tiles, num_factor, mem_need, mem_avail)
# Calculate
areal_per <- mclapply(1:length(output_tiles), function(n) {
# # Overlay the base and target map
base_map <- rast(input_tiles[n])
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, base_map, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(base_map, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname, base_map)
free_RAM(); gc()
areal_per_blk <- do.call(rbind, mclapply(1:nrow(cn), function(n) {
props <- get_proportion(cn[[n, 'input']], count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- cn[n, ]$id
dt[, c('id', count$value)]
}, mc.cores = nthread))
inds <- apply(areal_per_blk[, -1] == 10000, 1, match, x = TRUE)
areal_per_blk$cat <- count$value[inds]; rm(inds)
list(areal_per_blk, c(n_row, n_col))
}, mc.cores = min(length(output_tiles), nthread))
ncell_tiles <- sapply(areal_per, function(x) nrow(x[[1]]))
groups <- letters[seq_along(ncell_tiles)]
groups <- unlist(lapply(seq_along(ncell_tiles), function(n) {
rep(groups[n], ncell_tiles[n])}))
n_row_cols <- lapply(areal_per, function(x) x[[2]])
areal_per <- do.call(
rbind, lapply(areal_per, function(x) x[[1]]))
ids_in_group <- split(1:nrow(areal_per), groups)
rm(ncell_tiles, groups)
output
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- (input@ptr$mem_needs(opt)[1] +
output@ptr$mem_needs(opt)[1]) / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / floor(mem_avail / nthread))
num_tiles <- ifelse(num_tiles %/% 2 == 0, num_tiles, num_tiles + 1)
num_factor <- ceiling(sqrt(ncell(output) / num_tiles))
# Split raster to tiles
temp_dir <- file.path(tempdir(), 'tiles')
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
template
num_factor
devtools::document()
devtools::check()
7 * 0.6
ncell(output)
floor(sqrt(ncell(output) / 1500))
floor(sqrt(ncell(output) / 800))
floor(sqrt(ncell(output) / 1000))
floor(sqrt(ncell(output) / 1400))
floor(sqrt(ncell(output) / 1500))
floor(4 / nthread)
devtools::document()
devtools::check()
results <- rhub::check_for_cran()
library(terra)
library(dplyr)
library(sf)
nlcd_conus_path <- '/Users/leisong/Downloads/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
# Define an Area of Interest and transform to NLCD CRS
AOI <- USAboundaries::us_states(resolution = "low", states = 'Utah') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
rm(AOI, nlcd)
cellsize <- 1000
install.packages('install.packages('pbmcapply')')
install.packages('pbmcapply')
no_data = NA
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
# Remove levels if any
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname, overwrite = TRUE,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 10000))
}
}
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
library(parallel)
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- (input@ptr$mem_needs(opt)[1] +
output@ptr$mem_needs(opt)[1]) / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / mem_avail)
num_factor <- floor(sqrt(ncell(output) / num_tiles))
# The map would be too huge, just give it a try
if (num_factor <= 1) num_factor <- 2
num_factor
temp_dir <- file.path(tempdir(), 'tiles')
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
dims_out <- c(nrow(template), ncol(template))
output_tiles <- makeTiles(
output, template,
filename = file.path(temp_dir, 'output_.tif'))
rm(num_tiles, num_factor, mem_need, mem_avail)
rm(input, output, template); free_RAM(); gc()
library(pbmcapply)
# Calculate
areal_per <- pbmclapply(1:length(output_tiles), function(n) {
# # Overlay the base and target map
zones <- rast(output_tiles[n])
values(zones) <- 1:ncell(zones)
zones <- as.polygons(zones)
areal_per_blk <- do.call(rbind, mclapply(1:nrow(zones), function(m) {
props <- get_proportion(values(crop(rast(fname),
zones[m, ],
snap = 'out')),
count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
}, mc.cores = detectCores() - 1))
inds <- apply(areal_per_blk[, -1] == 10000, 1, match, x = TRUE)
areal_per_blk$cat <- count$value[inds]; rm(inds)
}, mc.cores = detectCores() - 1)
areal_per
# Calculate
areal_per <- pbmclapply(1:length(output_tiles), function(n) {
# # Overlay the base and target map
zones <- rast(output_tiles[n])
values(zones) <- 1:ncell(zones)
zones <- as.polygons(zones)
areal_per_blk <- do.call(rbind, mclapply(1:nrow(zones), function(m) {
props <- get_proportion(values(crop(rast(fname),
zones[m, ],
snap = 'out')),
count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
}, mc.cores = detectCores() - 1))
inds <- apply(areal_per_blk[, -1] == 10000, 1, match, x = TRUE)
areal_per_blk$cat <- count$value[inds]; rm(inds)
list(areal_per_blk, c(n_row, n_col))
}, mc.cores = detectCores() - 1)
gc()
n <- 1
fname
input
nlcd_conus_path <- '/Users/leisong/Downloads/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
# Define an Area of Interest and transform to NLCD CRS
AOI <- USAboundaries::us_states(resolution = "low", states = 'Utah') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
# Remove levels if any
levels(input) <- NULL
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- (input@ptr$mem_needs(opt)[1] +
output@ptr$mem_needs(opt)[1]) / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / mem_avail)
num_factor <- floor(sqrt(ncell(output) / num_tiles))
# The map would be too huge, just give it a try
if (num_factor <= 1) num_factor <- 2
num_factor
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- input@ptr$mem_needs(opt)[1] * 2 / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / mem_avail)
num_factor <- floor(sqrt(ncell(output) / num_tiles))
num_factor
# The map would be too huge, just give it a try
if (num_factor <= 1) num_factor <- 2
temp_dir <- file.path(tempdir(), 'tiles')
unlink(temp_dir, recursive = T)
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
dims_out <- c(nrow(template), ncol(template))
output_tiles <- makeTiles(
output, template,
filename = file.path(temp_dir, 'output_.tif'))
input_tiles <- makeTiles(
input, template,
filename = file.path(temp_dir, 'input_.tif'))
rm(num_tiles, num_factor, mem_need, mem_avail)
rm(input, output, template); free_RAM(); gc()
n
zones <- rast(output_tiles[n])
values(zones) <- 1:ncell(zones)
zones <- as.polygons(zones)
areal_per_blk <- do.call(rbind, mclapply(1:nrow(zones), function(m) {
props <- get_proportion(values(crop(rast(input_tiles[n]),
zones[m, ],
snap = 'out')),
count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
}, mc.cores = detectCores() - 1))
inds <- apply(areal_per_blk[, -1] == 10000, 1, match, x = TRUE)
areal_per_blk$cat <- count$value[inds]; rm(inds)
library(terra)
library(dplyr)
library(sf)
nlcd_conus_path <- '/Users/leisong/Downloads/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img'
nlcd <- rast(nlcd_conus_path)
# Define an Area of Interest and transform to NLCD CRS
AOI <- USAboundaries::us_states(resolution = "low", states = 'Utah') %>%
st_transform(crs(nlcd)) %>% vect()
input <- mask(crop(nlcd, AOI, snap = 'out'), AOI)
rm(AOI, nlcd)
cellsize <- 1000
?canProcessInMemory
??canProcessInMemory(x, 3)
??canProcessInMemory
canProcessInMemory(input, n = 4)
raster::canProcessInMemory(input, n = 4)
raster::canProcessInMemory(raster::raster(input), n = 4)
raster::canProcessInMemory(raster::raster(input), n = 0.1)
raster::canProcessInMemory(raster::raster(input), n = 0.2)
raster::canProcessInMemory(raster::raster(input), n = 0.3)
raster::canProcessInMemory(raster::raster(input), n = 0.4)
raster::canProcessInMemory(raster::raster(input), n = 0.5)
raster::canProcessInMemory(raster::raster(input), n = 0.6)
raster::canProcessInMemory(raster::raster(input), n = 0.7)
raster::canProcessInMemory(raster::raster(input), n = 1)
raster::canProcessInMemory(raster::raster(input), n = 3)
raster::canProcessInMemory(raster::raster(input), n = 2)
no_data = NA
library(parallel)
nthread <- detectCores()
# Make the output raster template
output <- rast(ext(input), crs = crs(input),
resolution = cellsize,
vals = NA)
levels(input) <- NULL
# Identify the corresponding number of cells in the output
## Step 1: calculate the percentage of each class in base map
## Step 2: calculate the rough number of pixels of each class in target map
## Step 3: adjust the remaining pixels
count <- data.frame(freq(input)[, c('value', 'count')])
# Get expected number of NAs in output
fname <- tempfile(fileext = '.tif')
num_vals_output <- freq(resample(input, output, method = 'near',
filename = fname, overwrite = TRUE,
wopt = list(gdal=c("COMPRESS=LZW"))),
value = NA)[[1, 'count']]
file.remove(fname)
# Calculate the expected number of pixels in the target map
count$count <- count$count / sum(count$count) *
(ncell(output) - num_vals_output)
# Floor the needed output values
count$output_count <- floor(count$count)
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
# In case there are more left pixels than classes
while (n_left > 0) {
inds <- order(count$count - count$output_count,
decreasing = TRUE)[1:n_left]
count$output_count[inds] = count$output_count[inds] + 1
n_left <- ncell(output) - num_vals_output - sum(count$output_count)
}; rm(n_left, inds, fname)
# Sort and remove classes with 0 needed cells
count <- count[count$output_count != 0, ]
count <- count[order(count$output_count), ]
# Determine which input cells underlay each output object
get_proportion <- function(x, classes) {
if (all(is.na(x))){
rep(NA, length(classes))
} else {
freqs <- data.frame(table(x))
names(freqs) <- c('class', 'freq')
freqs <- merge(data.frame(class = classes),
freqs, by = 'class', all = TRUE)
freqs <- freqs[match(classes, freqs$class), ]
as.integer(round(freqs$freq / length(x) * 10000))
}
}
## Do parallel according to operation platform
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply_hack},
Linux   = {mclapply},
Darwin  = {mclapply})
opt <- utils::getFromNamespace("spatOptions", "terra")()
opt$ncopies <- 1
mem_need <- input@ptr$mem_needs(opt)[1] * 2 / (1024^3 / 8)
mem_avail <- input@ptr$mem_needs(opt)[3] *
input@ptr$mem_needs(opt)[2] / (1024^3 / 8)
rm(opt)
# Calculate how many tiles to make
num_tiles <- ceiling(mem_need / mem_avail)
num_factor <- floor(sqrt(ncell(output) / num_tiles))
# The map would be too huge, just give it a try
if (num_factor <= 1) num_factor <- 2
temp_dir <- file.path(tempdir(), 'tiles')
if (!dir.exists(temp_dir)) dir.create(temp_dir)
template <- aggregate(output, fact = num_factor)
dims_out <- c(nrow(template), ncol(template))
output_tiles <- makeTiles(
output, template,
filename = file.path(temp_dir, 'output_.tif'))
input_tiles <- makeTiles(
input, template,
filename = file.path(temp_dir, 'input_.tif'))
rm(num_tiles, num_factor, mem_need, mem_avail)
rm(input, output, template); free_RAM(); gc()
n <- 1
Sys.time(
base_map <- rast(input_tiles[n])
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, base_map, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(base_map, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname, base_map)
free_RAM(); gc()
)
n <- 1
Sys.time({
base_map <- rast(input_tiles[n])
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, base_map, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(base_map, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname, base_map)
free_RAM(); gc()
})
n <- 1
tm <- Sys.time()
base_map <- rast(input_tiles[n])
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
values(zones) <- 1:ncell(zones)
fname <- tempfile(fileext = '.tif')
zones <- resample(zones, base_map, method = 'near',
filename = fname,
wopt = list(gdal=c("COMPRESS=LZW")))
cn <- zonal(base_map, zones, fun = function(x) list(x))
names(cn) <- c('id', 'input')
file.remove(fname); rm(zones, fname, base_map)
free_RAM(); gc()
Sys.time() - tm
tm <- Sys.time()
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
values(zones) <- 1:ncell(zones)
zones <- as.polygons(zones)
areal_per_blk <- do.call(rbind, mclapply(1:nrow(zones), function(m) {
props <- get_proportion(values(crop(rast(input_tiles[n]),
zones[m, ],
snap = 'out')),
count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
}, mc.cores = detectCores() - 1))
Sys.time() - tm
m <- 1
?stats::aggregate
xyFromCell(rast(out_tiles[n]), m)
xyFromCell(rast(output_tiles[n]), m)
rowColFromCell(rast(output_tiles[n]), m)
rowColFromCell(rast(output_tiles[n]), m)[1]
rowColFromCell(rast(output_tiles[n]), m)[2]
row_col <- rowColFromCell(rast(output_tiles[n]), m)
rast(output_tiles[n])[row_col[1], row_col[2], drop = FALSE]
props <- get_proportion(
values(crop(rast(input_tiles[n]),
rast(output_tiles[n])[row_col[1], row_col[2], drop = FALSE],
snap = 'out')), count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
tm <- Sys.time()
zones <- rast(output_tiles[n])
n_row <- nrow(zones); n_col <- ncol(zones)
areal_per_blk <- do.call(rbind, mclapply(1:ncell(zones), function(m) {
row_col <- rowColFromCell(rast(output_tiles[n]), m)
props <- get_proportion(
values(crop(rast(input_tiles[n]),
rast(output_tiles[n])[row_col[1], row_col[2], drop = FALSE],
snap = 'out')), count$value)
dt <- data.frame(t(props))
names(dt) <- count$value
dt$id <- m
dt[, c('id', count$value)]
}, mc.cores = detectCores() - 1))
Sys.time() - tm
gc()
free_RAM(); gc()
